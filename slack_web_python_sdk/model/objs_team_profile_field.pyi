# coding: utf-8

"""
    Slack Web API

    One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.

    The version of the OpenAPI document: 1.7.0
    Created by: https://api.slack.com/support
"""

from datetime import date, datetime  # noqa: F401
import decimal  # noqa: F401
import functools  # noqa: F401
import io  # noqa: F401
import re  # noqa: F401
import typing  # noqa: F401
import typing_extensions  # noqa: F401
import uuid  # noqa: F401

import frozendict  # noqa: F401

from slack_web_python_sdk import schemas  # noqa: F401


class ObjsTeamProfileField(
    schemas.DictSchema
):
    """
    This class is auto generated by Konfig (https://konfigthis.com)
    """


    class MetaOapg:
        required = {
            "ordering",
            "hint",
            "id",
            "label",
            "type",
        }
        
        class properties:
            hint = schemas.StrSchema
            
            
            class id(
                schemas.StrSchema
            ):
                pass
            label = schemas.StrSchema
            ordering = schemas.NumberSchema
            
            
            class type(
                schemas.EnumBase,
                schemas.StrSchema
            ):
                
                @schemas.classproperty
                def TEXT(cls):
                    return cls("text")
                
                @schemas.classproperty
                def DATE(cls):
                    return cls("date")
                
                @schemas.classproperty
                def LINK(cls):
                    return cls("link")
                
                @schemas.classproperty
                def MAILTO(cls):
                    return cls("mailto")
                
                @schemas.classproperty
                def OPTIONS_LIST(cls):
                    return cls("options_list")
                
                @schemas.classproperty
                def USER(cls):
                    return cls("user")
            
            
            class field_name(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'field_name':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            is_hidden = schemas.BoolSchema
            
            
            class options(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    
                    class items(
                        schemas.ComposedSchema,
                    ):
                    
                    
                        class MetaOapg:
                            any_of_0 = schemas.AnyTypeSchema
                            
                            @classmethod
                            @functools.lru_cache()
                            def any_of(cls):
                                # we need this here to make our import statements work
                                # we must store _composed_schemas in here so the code is only run
                                # when we invoke this method. If we kept this at the class
                                # level we would get an error because the class level
                                # code would be run when this module is imported, and these composed
                                # classes don't exist yet because their module has not finished
                                # loading
                                return [
                                    cls.any_of_0,
                                    ObjsTeamProfileFieldOption,
                                ]
                    
                    
                        def __new__(
                            cls,
                            *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                            _configuration: typing.Optional[schemas.Configuration] = None,
                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                        ) -> 'items':
                            return super().__new__(
                                cls,
                                *args,
                                _configuration=_configuration,
                                **kwargs,
                            )
            
                def __new__(
                    cls,
                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'options':
                    return super().__new__(
                        cls,
                        arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
        
            @staticmethod
            def possible_values() -> typing.Type['ObjsTeamProfileFieldPossibleValues']:
                return ObjsTeamProfileFieldPossibleValues
            __annotations__ = {
                "hint": hint,
                "id": id,
                "label": label,
                "ordering": ordering,
                "type": type,
                "field_name": field_name,
                "is_hidden": is_hidden,
                "options": options,
                "possible_values": possible_values,
            }
    
    ordering: MetaOapg.properties.ordering
    hint: MetaOapg.properties.hint
    id: MetaOapg.properties.id
    label: MetaOapg.properties.label
    type: MetaOapg.properties.type
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["hint"]) -> MetaOapg.properties.hint: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["label"]) -> MetaOapg.properties.label: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["ordering"]) -> MetaOapg.properties.ordering: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["field_name"]) -> MetaOapg.properties.field_name: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["is_hidden"]) -> MetaOapg.properties.is_hidden: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["options"]) -> MetaOapg.properties.options: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["possible_values"]) -> 'ObjsTeamProfileFieldPossibleValues': ...
    
    @typing.overload
    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
    
    def __getitem__(self, name: typing.Union[typing_extensions.Literal["hint", "id", "label", "ordering", "type", "field_name", "is_hidden", "options", "possible_values", ], str]):
        # dict_instance[name] accessor
        return super().__getitem__(name)
    
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["hint"]) -> MetaOapg.properties.hint: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["label"]) -> MetaOapg.properties.label: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["ordering"]) -> MetaOapg.properties.ordering: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["field_name"]) -> typing.Union[MetaOapg.properties.field_name, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["is_hidden"]) -> typing.Union[MetaOapg.properties.is_hidden, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["options"]) -> typing.Union[MetaOapg.properties.options, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["possible_values"]) -> typing.Union['ObjsTeamProfileFieldPossibleValues', schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
    
    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["hint", "id", "label", "ordering", "type", "field_name", "is_hidden", "options", "possible_values", ], str]):
        return super().get_item_oapg(name)
    

    def __new__(
        cls,
        *args: typing.Union[dict, frozendict.frozendict, ],
        ordering: typing.Union[MetaOapg.properties.ordering, decimal.Decimal, int, float, ],
        hint: typing.Union[MetaOapg.properties.hint, str, ],
        id: typing.Union[MetaOapg.properties.id, str, ],
        label: typing.Union[MetaOapg.properties.label, str, ],
        type: typing.Union[MetaOapg.properties.type, str, ],
        field_name: typing.Union[MetaOapg.properties.field_name, None, str, schemas.Unset] = schemas.unset,
        is_hidden: typing.Union[MetaOapg.properties.is_hidden, bool, schemas.Unset] = schemas.unset,
        options: typing.Union[MetaOapg.properties.options, list, tuple, schemas.Unset] = schemas.unset,
        possible_values: typing.Union['ObjsTeamProfileFieldPossibleValues', schemas.Unset] = schemas.unset,
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'ObjsTeamProfileField':
        return super().__new__(
            cls,
            *args,
            ordering=ordering,
            hint=hint,
            id=id,
            label=label,
            type=type,
            field_name=field_name,
            is_hidden=is_hidden,
            options=options,
            possible_values=possible_values,
            _configuration=_configuration,
            **kwargs,
        )

from slack_web_python_sdk.model.objs_team_profile_field_option import ObjsTeamProfileFieldOption
from slack_web_python_sdk.model.objs_team_profile_field_possible_values import ObjsTeamProfileFieldPossibleValues
